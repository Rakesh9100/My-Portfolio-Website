<!-- Preloader -->
<div id="loading" class="fixed inset-0 z-[99999] flex items-center justify-center transition-opacity duration-500" style="background-color: var(--main1);">
    <div class="flex flex-col items-center gap-6">
        <!-- Logo -->
        <div class="relative w-[120px] h-[120px] flex items-center justify-center">
            <span class="text-[52px] font-black preloader-gradient-text select-none leading-none">
                RR
            </span>

            <!-- Soft Pulse Ring -->
            <span class="preloader-ring"></span>
        </div>

        <!-- Progress -->
        <div class="w-[280px]">
            <div class="h-1 rounded-full overflow-hidden" style="background-color: rgba(0, 0, 0, 0.3);">
                <div id="progress-bar" class="h-full w-0 preloader-progress-bg transition-[width] duration-300">
                </div>
            </div>

            <p id="progress-percentage" class="mt-2 text-sm text-center tracking-widest font-variant-numeric-tabular" style="color: var(--secondary); opacity: 0.7;">
                0%
            </p>
        </div>

        <!-- Tagline -->
        <p class="text-xs uppercase tracking-[3px]" style="color: var(--secondary); opacity: 0.5;">
            Automating the Future
        </p>
    </div>
</div>

<style>
    #loading {
        will-change: opacity;
    }

    @keyframes gradientShift {
        0% {
            background-position: 0% 50%;
        }

        100% {
            background-position: 100% 50%;
        }
    }

    .preloader-gradient-text {
        background: var(--navbar);
        background-size: 200% 200%;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        animation: gradientShift 6s linear infinite;
    }

    @keyframes softPulse {

        0%,
        100% {
            transform: scale(1);
            opacity: 0.6;
        }

        50% {
            transform: scale(1.05);
            opacity: 1;
        }
    }

    .preloader-ring {
        position: absolute;
        inset: -6px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.15);
        animation: softPulse 2.5s ease-in-out infinite;
        pointer-events: none;
        box-shadow: 0 0 20px var(--primary);
    }

    .preloader-progress-bg {
        position: relative;
        background: var(--navbar);
        background-size: 200% 200%;
        overflow: hidden;
    }

    .preloader-progress-bg,
    .preloader-gradient-text {
        animation: gradientShift 6s linear infinite;
    }

    @keyframes shimmer {
        0% {
            transform: translateX(-100%);
        }

        100% {
            transform: translateX(100%);
        }
    }

    .preloader-progress-bg::after {
        content: '';
        position: absolute;
        inset: 0;
        background: linear-gradient(90deg,
                transparent,
                rgba(255, 255, 255, 0.35),
                transparent);
        transform: translateX(-100%);
        animation: shimmer 2.5s infinite;
    }

    .font-variant-numeric-tabular {
        font-variant-numeric: tabular-nums;
    }
</style>

<script>
    const loader = document.getElementById('loading');
    const progressBar = document.getElementById('progress-bar');
    const progressText = document.getElementById('progress-percentage');

    let progress = 0;
    let isCompleted = false;
    const hasHash = window.location.hash;

    // Asset tracking with better error handling
    let totalAssets = 0;
    let loadedAssets = 0;
    let assetsTracked = false;
    let progressTimer: ReturnType<typeof setTimeout> | null = null;

    function updateProgress(newProgress: number) {
        if (isCompleted) return;

        progress = Math.min(100, Math.max(0, newProgress));
        if (progressBar) progressBar.style.width = progress + '%';
        if (progressText) progressText.textContent = Math.round(progress) + '%';

        // Clear any existing timer
        if (progressTimer) {
            clearTimeout(progressTimer);
        }

        // Auto-complete if we're stuck near 100%
        if (progress >= 95 && progress < 100) {
            progressTimer = setTimeout(() => {
                if (!isCompleted) {
                    updateProgress(100);
                }
            }, 1000);
        }

        if (progress >= 100) {
            completeLoading();
        }
    }

    function completeLoading() {
        if (isCompleted) return;
        isCompleted = true;

        if (progressTimer) {
            clearTimeout(progressTimer);
        }

        if (loader) {
            loader.style.opacity = '0';

            setTimeout(() => {
                if (loader) {
                    loader.style.display = 'none';
                    document.body.classList.add('loaded');

                    if (hasHash) {
                        const target = document.querySelector(hasHash);
                        if (target instanceof HTMLElement) {
                            const offset = 80;
                            window.scrollTo({
                                top: target.offsetTop - offset,
                                behavior: 'smooth'
                            });
                        }
                    }
                }
            }, 400);
        }
    }

    function onAssetLoaded() {
        if (isCompleted) return;

        loadedAssets++;

        // Ensure we don't exceed totalAssets
        if (loadedAssets > totalAssets) {
            loadedAssets = totalAssets;
        }

        const assetProgress = totalAssets > 0 ? (loadedAssets / totalAssets) * 75 : 75; // 75% for assets
        const baseProgress = hasHash ? 20 : 15;
        const finalProgress = baseProgress + assetProgress;

        updateProgress(finalProgress);
    }

    function trackAssetLoading() {
        if (assetsTracked || isCompleted) return;
        assetsTracked = true;

        // Start with initial progress
        updateProgress(hasHash ? 20 : 15);

        // Get all images with better filtering
        const images = Array.from(document.querySelectorAll('img')).filter(img =>
            img.src && !img.src.startsWith('data:')
        );

        // Simplified background image detection - only check specific selectors
        const bgImageElements = Array.from(document.querySelectorAll('[style*="background-image"], .bg-')).filter(el => {
            const computedStyle = window.getComputedStyle(el);
            const bgImage = computedStyle.backgroundImage;
            return bgImage && bgImage !== 'none' && bgImage.includes('url(');
        });

        // Calculate total assets (simplified)
        totalAssets = images.length + bgImageElements.length;

        // Add a minimum of 1 to prevent division by zero
        if (totalAssets === 0) {
            totalAssets = 1;
            loadedAssets = 1;
            updateProgress(100);
            return;
        }

        // Track image loading with timeout per image
        images.forEach((img, index) => {
            if (img.complete && img.naturalHeight !== 0) {
                onAssetLoaded();
            } else {
                let imageLoaded = false;

                const handleLoad = () => {
                    if (!imageLoaded) {
                        imageLoaded = true;
                        onAssetLoaded();
                    }
                };

                img.addEventListener('load', handleLoad, { once: true });
                img.addEventListener('error', handleLoad, { once: true });

                // Individual timeout for each image
                setTimeout(() => {
                    if (!imageLoaded) {
                        imageLoaded = true;
                        onAssetLoaded();
                    }
                }, 3000);
            }
        });

        // Track background images with better error handling
        bgImageElements.forEach((el, index) => {
            const computedStyle = window.getComputedStyle(el);
            const bgImage = computedStyle.backgroundImage;
            const urlMatch = bgImage.match(/url\(['"]?([^'"]+)['"]?\)/);

            if (urlMatch) {
                let bgLoaded = false;
                const img = new Image();

                const handleBgLoad = () => {
                    if (!bgLoaded) {
                        bgLoaded = true;
                        onAssetLoaded();
                    }
                };

                img.onload = handleBgLoad;
                img.onerror = handleBgLoad;
                img.src = urlMatch[1];

                // Timeout for background images
                setTimeout(() => {
                    if (!bgLoaded) {
                        bgLoaded = true;
                        onAssetLoaded();
                    }
                }, 3000);
            } else {
                onAssetLoaded();
            }
        });

        // Global fallback timeout - reduced from 8s to 5s
        setTimeout(() => {
            if (!isCompleted && progress < 100) {
                updateProgress(100);
            }
        }, 5000);
    }

    // Initialize preloader
    function initPreloader() {
        // Reduced delay from 100ms to 50ms
        setTimeout(trackAssetLoading, 50);
    }

    // Initialize based on document state
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initPreloader);
    } else {
        initPreloader();
    }

    // More aggressive backup completion
    window.addEventListener('load', () => {
        setTimeout(() => {
            if (!isCompleted && progress < 100) {
                updateProgress(100);
            }
        }, 200);
    });

    // Additional safety net for page visibility
    document.addEventListener('visibilitychange', () => {
        if (!document.hidden && !isCompleted && progress > 90) {
            setTimeout(() => {
                if (!isCompleted) {
                    updateProgress(100);
                }
            }, 500);
        }
    });
</script>